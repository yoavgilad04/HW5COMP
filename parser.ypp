%{
#include "source.hpp"
#include "staff/hw3_output.hpp"
#include <iostream>
#include <stdlib.h>
#include "staff/bp.hpp"

#include "table_stack.hpp"
#include "singleton.hpp"
using namespace std;
extern int yylex();
void yyerror(const char*);
extern TableStack table_stack;
extern int loop_count;
Singleton* Singleton::sin_instance = nullptr;
Singleton* shaked = Singleton::getInstance();
CodeBuffer* code_buffer = shaked->code_buffer;
extern bool in_function;
extern bool after_label;
extern vector<While*> whiles;
%}

%nonassoc STRING;
%nonassoc VOID;
%nonassoc INT;
%nonassoc BYTE;
%nonassoc BOOL;
%nonassoc B;
%nonassoc TRUE;
%nonassoc FALSE;
%nonassoc RETURN;
%nonassoc WHILE;
%nonassoc BREAK;
%nonassoc CONTINUE;
%nonassoc SC;
%nonassoc COMMA;
%nonassoc RBRACE;
%nonassoc LBRACE;
%nonassoc OVERRIDE;
%nonassoc NUM;
%nonassoc ID;

%right ASSIGN;

%left OR;
%left AND;
%left EQLOP;
%left RELOP;
%left ADD;
%left MUL;

%right NOT;

%left RPAREN;
%left LPAREN;

%right IF;
%right ELSE;

%%

Program:        M Funcs                                                             {output::printProductionRule(1);
                                                                                     table_stack.closeScope();
                                                                                     shaked->printBuffer();};
Funcs:          epsilon                                                             {output::printProductionRule(2);}
                | FuncDecl Funcs                                                    {output::printProductionRule(3);}
;

M: epsilon                                                                          {table_stack.openNewScope();
                                                                                     table_stack.addFuncSymbol("print", "VOID", "STRING", "default", "print");
                                                                                     table_stack.addFuncSymbol("printi", "VOID", "INT", "default", "printi");
                                                                                     code_buffer->emitGlobal("declare i32 @printf(i8*, ...)");
                                                                                     code_buffer->emitGlobal("declare void @exit(i32)");
                                                                                     code_buffer->emitGlobal("@.int_specifier = constant [4 x i8] c\"%d\\0A\\00\"");
                                                                                     code_buffer->emitGlobal("@.str_specifier = constant [4 x i8] c\"%s\\0A\\00\"");
                                                                                     code_buffer->emitGlobal("@.devide_by_zero_error = constant [24 x i8] c\"Error division by zero\\0A\\00\"");
                                                                                     shaked->makePrintImplementation();
                                                                                     shaked->addCheckIfZeroFunction();
                                                                                     in_function = false;}
;
N: epsilon                                                                          {table_stack.openNewScope();}
;
C: epsilon                                                                          {table_stack.closeScope();}
;
X: OverRide RetType ID LPAREN Formals                                               {string new_var = shaked->getFreshVar();
                                                                                     table_stack.addFuncSymbol($3->getType(), $2->getType(), $5->getType(), $1->getType(), new_var);
                                                                                     shaked->addFunction(table_stack.getLastFuncSymbol());
                                                                                     code_buffer->emit("{");
                                                                                     int num_of_args = TableStack::splitString($5->getType()).size();
                                                                                     shaked->addFuncVars(num_of_args);
                                                                                     in_function = true;
                                                                                     }
;
FuncDecl:  X RPAREN LBRACE Statements RBRACE                                        {output::printProductionRule(4);
                                                                                     in_function = false;
                                                                                     code_buffer->emit("}");
                                                                                     code_buffer->emit("");
                                                                                     table_stack.closeScope();}
;
OverRide:       epsilon                                                             {output::printProductionRule(5);
                                                                                     $$ = new Node();
                                                                                     table_stack.openNewScope();}
                | OVERRIDE                                                          {output::printProductionRule(6);
                                                                                     $$ = new Node("OVERRIDE");
                                                                                     table_stack.openNewScope();}
;
RetType:        Type                                                                {output::printProductionRule(7);
                                                                                     $$ = $1;}
                | VOID                                                              {output::printProductionRule(8);
                                                                                     $$ = $1;}
;
Formals:        epsilon                                                             {output::printProductionRule(9);
                                                                                     $$ = new FormalList();}
                | FormalsList                                                       {output::printProductionRule(10);
                                                                                     $$ = new FormalList(*$1);}
;
FormalsList:    FormalDecl                                                          {output::printProductionRule(11);
                                                                                     $$ = new FormalList(*$1);}
                | FormalDecl COMMA FormalsList                                      {output::printProductionRule(12);
                                                                                     $$ = new FormalList(*$1, *$3);}
;
FormalDecl:     Type ID                                                             {output::printProductionRule(13);
                                                                                     table_stack.addSymbolToLastTable($2->getType(), $1->getType(), true);}
;
Statements:     Statement                                                           {output::printProductionRule(14);}
                | Statements Statement                                              {output::printProductionRule(15);}
;
Statement:      LBRACE N Statements RBRACE C                                        {output::printProductionRule(16);}
                | Type ID SC                                                        {output::printProductionRule(17);
                                                                                    string new_var = shaked->getFreshVar();
                                                                                    table_stack.addSymbolToLastTable($2->getType(), $1->getType(), false, new_var);
                                                                                    Symbol* inserted_symbol = table_stack.searchForSymbol($2->getType());
                                                                                    //code_buffer->emit(shaked->allocCommand(new_var, $1->getType()));
                                                                                    shaked->storeCommand(new_var, $1->getType(), "0", inserted_symbol->getOffset());}
                | Type ID ASSIGN Exp SC                                             {output::printProductionRule(18);
                                                                                    string new_var = shaked->getFreshVar();
                                                                                    Exp* exp = dynamic_cast<Exp*>($4);
                                                                                    string exp_llvm_name = exp->getLLVMName();
                                                                                    table_stack.addSymbolToLastTable($2->getType(), $1->getType(), $4->getType(), new_var);
                                                                                    if ($1->getType() == "BOOL")
                                                                                    {
                                                                                        string true_case = code_buffer->genLabel();
                                                                                        shaked->addAssignmentCommand(new_var, "1");
                                                                                        int true_jump_address = code_buffer->emit(shaked->makeGoToStatement());
                                                                                        string false_case = code_buffer->genLabel();
                                                                                        shaked->addAssignmentCommand(new_var, "0");
                                                                                        code_buffer->bpatch(exp->getTrueList(), true_case);
                                                                                        code_buffer->bpatch(exp->getFalseList(), false_case);
                                                                                        string next_case = code_buffer->genLabel();
                                                                                        code_buffer->bpatch(code_buffer->makelist(pair<int,BranchLabelIndex>{true_jump_address, FIRST}),next_case);

                                                                                    }
                                                                                    Symbol* inserted_symbol = table_stack.searchForSymbol($2->getType());
                                                                                    //code_buffer->emit(shaked->allocCommand(new_var, $1->getType()));
                                                                                    shaked->storeCommand(new_var, $1->getType(), exp_llvm_name, inserted_symbol->getOffset());

                                                                                    }
                | ID ASSIGN Exp SC                                                  {output::printProductionRule(19);
                                                                                    Exp* exp = dynamic_cast<Exp*>($3);
                                                                                    string exp_llvm_name = exp->getLLVMName();
                                                                                    table_stack.compareType($1->getType(), $3->getType());
                                                                                    Symbol* s = table_stack.searchForSymbol($1->getType());
                                                                                    shaked->storeCommand(s->getLLVMName(), s->getType(), exp_llvm_name, s->getOffset());
                                                                                    }
                | Call SC                                                           {output::printProductionRule(20);}
                | RETURN SC                                                         {output::printProductionRule(21);
                                                                                     table_stack.checkReturnType("VOID");
                                                                                     code_buffer->emit(shaked->retCommand());}
                | RETURN Exp SC                                                     {output::printProductionRule(22);
                                                                                     table_stack.checkReturnType($2->getType());}
                | IF LPAREN BOOLEXP RPAREN IFN Statement C                           {output::printProductionRule(23);
                                                                                     string false_label = code_buffer->genLabel();
                                                                                     Exp* boolexp = dynamic_cast<Exp*>($3);
                                                                                     code_buffer->bpatch(boolexp->getTrueList(), $5->getType());
                                                                                     code_buffer->bpatch(boolexp->getFalseList(), false_label);
                                                                                     }

                | IF LPAREN BOOLEXP RPAREN IFN Statement C ELSE IFN2 Statement C     {output::printProductionRule(24);
                                                                                     Exp* boolexp = dynamic_cast<Exp*>($3);
                                                                                     code_buffer->bpatch(boolexp->getTrueList(), $5->getType());
                                                                                     code_buffer->bpatch(boolexp->getFalseList(), $9->getType());
                                                                                     string next_label = code_buffer->genLabel();
                                                                                     code_buffer->bpatch(code_buffer->makelist(pair<int,BranchLabelIndex>{$9->getLine(),FIRST}), next_label);
                                                                                     }

                | WHILE LPAREN MBPW BOOLEXP RPAREN INLOOP IFN Statement OFFLOOP C   {
                                                                                      output::printProductionRule(25);
                                                                                      Exp* boolexp = dynamic_cast<Exp*>($4);
                                                                                      code_buffer->bpatch(boolexp->getTrueList(), $7->getType());
                                                                                      string next_label = code_buffer->genLabel();
                                                                                      code_buffer->bpatch(boolexp->getFalseList(),next_label);
                                                                                      string start_loop_label = $3->getType();
                                                                                      code_buffer->bpatch(code_buffer->makelist(pair<int,BranchLabelIndex>{$9->getLine(),FIRST}),start_loop_label);
                                                                                      While* last_while = whiles.back();
                                                                                      code_buffer->bpatch(code_buffer->merge(boolexp->getFalseList(), last_while->getList()),next_label);
                                                                                      whiles.pop_back();
                                                                                      delete last_while;
                                                                                     }

                | BREAK SC                                                          {if (loop_count == 0)
                                                                                     output::errorUnexpectedBreak(yylineno);
                                                                                     output::printProductionRule(26);
                                                                                     int goto_line = code_buffer->emit(shaked->makeGoToStatement());
                                                                                     While* last_while = whiles.back();
                                                                                     last_while->setList(code_buffer->merge(last_while->getList(), code_buffer->makelist({goto_line, FIRST})));}

                | CONTINUE SC                                                       {if (loop_count == 0)
                                                                                     output::errorUnexpectedContinue(yylineno);
                                                                                     output::printProductionRule(27);
                                                                                     int goto_line = code_buffer->emit(shaked->makeGoToStatement());
                                                                                     While* last_while = whiles.back();
                                                                                     code_buffer->bpatch(code_buffer->makelist(pair<int,BranchLabelIndex>{goto_line,FIRST}),last_while->getLabel());
                                                                                     }
;

IFN: epsilon                                                                          {table_stack.openNewScope();
                                                                                       $$ = new Node(shaked->code_buffer->genLabel());}
;

MBPW:   epsilon                                                                    {string goto_label = shaked->code_buffer->genLabel();
                                                                                    $$=new Node(goto_label);
                                                                                    While* w = new While(goto_label);
                                                                                    whiles.push_back(w);
                                                                                    }

IFN2: epsilon                                                                          {table_stack.openNewScope();
                                                                                       int br_line = code_buffer->emit(shaked->makeGoToStatement());
                                                                                       $$ = new Node(shaked->code_buffer->genLabel());
                                                                                       $$->setLine(br_line);}
;

INLOOP: epsilon                                                                     {loop_count++;}
;
OFFLOOP: epsilon                                                                    {
                                                                                     loop_count--;
                                                                                     int br_line = code_buffer->emit(shaked->makeGoToStatement());
                                                                                     $$ = new Node(br_line);}
;
BOOLEXP: Exp                                                                        {if($1->getType()!="BOOL")
                                                                                    output::errorMismatch(yylineno);
                                                                                    $$ = $1;
                                                                                    }
;

Call:           ID LPAREN ExpList RPAREN                                            {output::printProductionRule(28);
                                                                                     $$ = new Call(*$1, $3);}
                | ID LPAREN RPAREN                                                  {output::printProductionRule(29);
                                                                                     $$ = new Call(*$1);}
;
ExpList:        Exp                                                                 {output::printProductionRule(30);
                                                                                     $$ = new ExpList(*$1);}
                | Exp COMMA ExpList                                                 {output::printProductionRule(31);
                                                                                     $$ = new ExpList(*$1, $3);}
;
Type:           INT                                                                 {output::printProductionRule(32);
                                                                                     $$ = new Node("INT");}
                | BYTE                                                              {output::printProductionRule(33);
                                                                                     $$ = new Node("BYTE");}
                | BOOL                                                              {output::printProductionRule(34);
                                                                                     $$ = new Node ("BOOL");}
;
Exp:            LPAREN Exp RPAREN                                                   {output::printProductionRule(35);
                                                                                     $$ = $2;}
                | Exp ADD Exp                                                       {output::printProductionRule(36);
                                                                                     $$ = new Exp("binop", *$1, *$3, $2->getType());}
                | Exp MUL Exp                                                       {output::printProductionRule(36);
                                                                                     $$ = new Exp("binop", *$1, *$3, $2->getType());}
                | ID                                                                {output::printProductionRule(37);
                                                                                     $$ = new Exp(*$1, "id");}
                | Call                                                              {output::printProductionRule(38);
                                                                                     $$ = new Exp(*$1, "call");}
                | NUM                                                               {output::printProductionRule(39);
                                                                                     $$ = new Exp("INT", $1->getType());}
                | NUM B                                                             {output::printProductionRule(40);
                                                                                     $$ = new Exp(*$1);}
                | STRING                                                            {output::printProductionRule(41);
                                                                                     $$ = new Exp("STRING", $1->getType());}
                | TRUE                                                              {output::printProductionRule(42);
                                                                                     $$ = new Exp("BOOL", $1->getType());}
                | FALSE                                                             {output::printProductionRule(43);
                                                                                     $$ = new Exp("BOOL", $1->getType());}
                | NOT Exp                                                           {output::printProductionRule(44);
                                                                                     $$ = new Exp(*$2, "not");}
                | Exp AND MBP Exp                                                       {output::printProductionRule(45);
                                                                                     $$ = new Exp(*$1, "bool_op", *$4, $2->getType(), $3->getType());}
                | Exp OR MBP Exp                                                        {output::printProductionRule(46);
                                                                                     $$ = new Exp(*$1, "bool_op", *$4, $2->getType(), $3->getType());}
                | Exp RELOP Exp                                                     {output::printProductionRule(47);
                                                                                     $$ = new Exp("relop", *$1, *$3, $2->getType());}
                | Exp EQLOP Exp                                                     {output::printProductionRule(47);
                                                                                     $$ = new Exp("relop", *$1, *$3, $2->getType());}
                | LPAREN Type RPAREN Exp                                            {output::printProductionRule(48);
                                                                                     $$ = new Exp(*$4, $2->getType());}
;
MBP:            epsilon                                                             {$$=new Node(shaked->code_buffer->genLabel());}
;
epsilon:        %empty;

%%
 //i AM SHAKED
void yyerror(const char * message)
{
    output::errorSyn(yylineno);
    exit(0);
}

int main()
{
	return yyparse();
}